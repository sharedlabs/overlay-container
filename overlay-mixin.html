<script>

  window.OverlayMixin = subclass => class extends subclass {

    static get properties() {
      return {

        opened: {
          type: Boolean,
          notify: true,
          observer: '_openedChanged'
        },

        noCancelOnEscKey: {
          type: Boolean,
          value: false
        },

        noCancelOnPopState: {
          type: Boolean,
          value: false
        },

        cancelOnOutsideClick: {
          type: Boolean,
          value: false
        },

        removeOnClose: {
          type: Boolean,
          value: false
        },

        closeOthers: {
          type: Boolean,
          value: false
        },

        onDetach: {
          type: Function
        },

        canceled: {
          type: Boolean,
          readOnly: true,
          value: false
        },

        noAutoFocus: {
          type: Boolean,
          value: false
        },

        parentContainer: {
          type: Object,
          value: document.body
        }

      };
    }

    constructor() {
      super();
      this.__onOverlayKeydown = this.__onOverlayKeydown.bind(this);
      this._handleCancelOnOutsideClick = this._handleCancelOnOutsideClick.bind(this);
    }

    connectedCallback() {
      super.connectedCallback();
      this._ensureAttribute('tabindex', -1);
      requestAnimationFrame(_ => {
        this.__toggleOverlayListeners({enable: true});
      });
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      if (this.opened) {
        this.opened = false;
        this.__dispatchOverlayEvent('overlay-closed', {node: this.parentContainer});
      }
      this.__dispatchOverlayEvent('overlay-detached', {node: this.parentContainer});
      this.__dispatchOverlayEvent('overlay-detached');
      this.__toggleOverlayListeners({enable: false});
      if (typeof this.onDetach === 'function') {
        this.onDetach();
      }
    }

    open() {
      this.opened = true;
      this._openedChanged(this.opened);
    }

    _openedChanged(opened, old) {
      if (opened) {
        this.__beforeOpen();
        this._setCanceled(false);
        this.style.display = '';
        if (!this.noAutoFocus) {
          this.focus();
        }
        this.__dispatchOverlayEvent('overlay-opened');
      } else {
        this.style.display = 'none';
      }
      if (old) {
        this.__dispatchOverlayEvent('overlay-closed');
      }
      if (!opened && this.removeOnClose) {
        this.remove();
      }
    }

    __beforeOpen() {
      this.__dispatchOverlayEvent('before-open-overlay', {
        node: document.body
      });
      if ((!this.isConnected) ||
          (this.parentElement !== this.parentContainer)) {
        // Attach the overlay to the parentContainer
        this.parentContainer.appendChild(this);
      }
    }

    _handleCancelOnOutsideClick(event) {
      if (!this.cancelOnOutsideClick) {
        return;
      }
      const path = event.composedPath();
      let permitted;
      for (let i = 0; i < path.length; i++) {
        if (path[i] === this) {
          permitted = true;
          break;
        }
      }
      if (!permitted) {
        this.opened = false;
      }
    }

    __toggleOverlayListeners({enable}) {
      const m = enable ? 'addEventListener' : 'removeEventListener';
      this[m]('keydown', this.__onOverlayKeydown);
      document[m]('mousedown', this._handleCancelOnOutsideClick);
    }

    __onOverlayKeydown(event) {
      const escKey = 27;
      if (!this.noCancelOnEscKey && event.keyCode === escKey) {
        this._setCanceled(true);
        this.opened = false;
      }
    }

    __dispatchOverlayEvent(eventName, {node = this, cancelable = false} = {}) {
      node.dispatchEvent(new CustomEvent(eventName, {
        bubbles: true,
        composed: true,
        cancelable,
        detail: {
          overlay: this
        }
      }));
    }

  };

</script>
