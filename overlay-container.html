
<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="overlay-container">
  <template>
    <style>
      #overlays {
        pointer-events: all;
      }

      :host([with-backdrop]) .backdrop {
        bottom: 0;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
      }
    </style>

    <div class="backdrop"></div>
    <div id="overlays"></div>

  </template>

  <script>

    class OverlayContainer extends Polymer.Element {

      static get is() {return 'overlay-container';}

      static get properties() {
        return {

          withBackdrop: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          }

        };
      }

      constructor() {
        super();
        this.__beforeOpenOverlay = this.__beforeOpenOverlay.bind(this);
        this.__onOverlayOpened = this.__onOverlayOpened.bind(this);
        this.__onOverlayClosed = this.__onOverlayClosed.bind(this);
        this.__onPopstate = this.__onPopstate.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        requestAnimationFrame(_ => {
          this.__toggleListeners({enable: true});
        });
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.__toggleListeners({enable: false});
      }

      __toggleListeners({enable}) {
        const m = enable ? 'addEventListener' : 'removeEventListener';
        document.body[m]('before-open-overlay', this.__beforeOpenOverlay);
        this[m]('overlay-opened', this.__onOverlayOpened);
        this[m]('overlay-closed', this.__onOverlayClosed);
        window[m]('popstate', this.__onPopstate);
      }

      __beforeOpenOverlay(event) {
        const overlay = event.detail.overlay;
        overlay.parentContainer = this.$.overlays;
        this.__handleCloseOthers(overlay);
      }

      __onOverlayOpened(event) {
        const overlay = event.detail.overlay;
        if (!overlay.noCancelOnPopState) {
          history.pushState({}, '', location.href);
        }
        this.__updateBackdrop();
      }

      __onOverlayClosed(event) {
        const overlay = this.__getLastOverlay();
        if (overlay && !this.__isOverlayOrDescendantFocused(overlay)) {
          overlay.focus();
        }
        this.__updateBackdrop();
      }

      __onPopstate() {
        const overlay = this.__getLastOverlay();
        if (overlay && !overlay.noCancelOnPopState) {
          overlay._setCanceled(true);
          overlay.opened = false;
        }
      }

      /**
       * If the given overlay have the `close others` property set to true, it will
       * close any other instance of the same overlay.
       */
      __handleCloseOthers(overlay) {
        if (overlay.closeOthers) {
          const c$ = this.$.overlays.children;
          for (let i = c$.length - 1; i >= 0; i--) {
            if (c$[i] !== overlay && c$[i].opened) {
              c$[i].opened = false;
              break;
            }
          }
        }
      }

      __updateBackdrop() {
        let withBackdrop = false;
        const c$ = this.$.overlays.children;
        for (let i = c$.length - 1; i >= 0; i--) {
          if (c$[i].opened && c$[i].cancelOnOutsideClick) {
            withBackdrop = true;
            break;
          }
        }
        this.withBackdrop = withBackdrop;
      }

      __getLastOverlay() {
        const c$ = this.$.overlays.children;
        for (let i = c$.length - 1; i >= 0; i--) {
          if (c$[i].opened) {
            return c$[i];
          }
        }
      }

      __isOverlayOrDescendantFocused(overlay) {
        const activeElement = this.__getDeepActiveElement();
        if (activeElement) {
          let node = activeElement;
          while(node && node !== this) {
            if (node === overlay) {
              return true;
            }
            node = node.parentNode || node.host;
          }
        }
        return false;
      }

      __getDeepActiveElement() {
        var activeElement = document.activeElement;
        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
          activeElement = activeElement.shadowRoot.activeElement;
        return activeElement;
      }

    }

    customElements.define(OverlayContainer.is, OverlayContainer);

  </script>
</dom-module>